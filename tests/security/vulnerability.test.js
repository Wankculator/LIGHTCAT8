// Security vulnerability tests

const request = require('supertest');
const app = require('../../server/app');
const TestUtils = require('../helpers/test-utils');
const crypto = require('crypto');

describe('Security Vulnerability Tests', () => {
    let server;
    
    beforeAll(() => {
        server = app.listen(0);
    });
    
    afterAll((done) => {
        server.close(done);
    });
    
    describe('Input Validation', () => {
        test('should prevent SQL injection in RGB invoice', async () => {
            const maliciousInputs = [
                "'; DROP TABLE purchases; --",
                "1' OR '1'='1",
                "rgb:utxob:test' UNION SELECT * FROM users--",
                "<script>alert('xss')</script>",
                "../../etc/passwd"
            ];
            
            for (const input of maliciousInputs) {
                const response = await request(server)
                    .post('/api/rgb/invoice')
                    .send({
                        rgbInvoice: input,
                        batchCount: 1,
                        walletAddress: TestUtils.generateBitcoinAddress()
                    });
                
                expect(response.status).toBe(400);
                expect(response.body.error).toContain('Invalid RGB invoice');
                // Ensure no SQL error is exposed
                expect(response.body.error).not.toMatch(/SQL|syntax|database/i);
            }
        });
        
        test('should prevent XSS in wallet address', async () => {
            const xssPayloads = [
                '<script>alert("xss")</script>',
                '<img src=x onerror=alert("xss")>',
                'javascript:alert("xss")',
                '<iframe src="javascript:alert(\'xss\')"></iframe>',
                '"><script>alert(String.fromCharCode(88,83,83))</script>'
            ];
            
            for (const payload of xssPayloads) {
                const response = await request(server)
                    .post('/api/rgb/invoice')
                    .send({
                        rgbInvoice: TestUtils.generateRGBInvoice(),
                        batchCount: 1,
                        walletAddress: payload
                    });
                
                expect(response.status).toBe(400);
                expect(response.body.error).toContain('Invalid');
                // Ensure payload is not reflected
                expect(response.body.error).not.toContain(payload);
            }
        });
        
        test('should validate batch count boundaries', async () => {
            const invalidCounts = [
                -1,
                0,
                11, // Exceeds gold tier
                999999,
                Infinity,
                NaN,
                null,
                undefined,
                '5; DROP TABLE--',
                { malicious: 'object' },
                [1, 2, 3]
            ];
            
            for (const count of invalidCounts) {
                const response = await request(server)
                    .post('/api/rgb/invoice')
                    .send({
                        rgbInvoice: TestUtils.generateRGBInvoice(),
                        batchCount: count,
                        walletAddress: TestUtils.generateBitcoinAddress()
                    });
                
                expect(response.status).toBe(400);
                expect(response.body.success).toBe(false);
            }
        });
    });
    
    describe('Authentication & Authorization', () => {
        test('should not expose internal endpoints', async () => {
            const internalEndpoints = [
                '/admin',
                '/api/internal/debug',
                '/api/config',
                '/.env',
                '/api/database/query',
                '/api/system/info'
            ];
            
            for (const endpoint of internalEndpoints) {
                const response = await request(server).get(endpoint);
                expect([404, 401, 403]).toContain(response.status);
                // Should not expose internal information
                expect(response.text).not.toMatch(/password|secret|key|token/i);
            }
        });
        
        test('should validate webhook signatures', async () => {
            const webhookData = {
                type: 'InvoicePaid',
                invoiceId: 'test-123',
                btcPaid: '0.00002'
            };
            
            // Without signature
            const response1 = await request(server)
                .post('/api/webhooks/lightning')
                .send(webhookData)
                .expect(401);
            
            expect(response1.body.error).toContain('signature');
            
            // With invalid signature
            const response2 = await request(server)
                .post('/api/webhooks/lightning')
                .set('x-btcpay-signature', 'invalid-signature')
                .send(webhookData)
                .expect(401);
            
            expect(response2.body.error).toContain('Invalid');
        });
    });
    
    describe('Rate Limiting', () => {
        test('should enforce rate limits on sensitive endpoints', async () => {
            const endpoints = [
                { path: '/api/rgb/invoice', limit: 10, window: 5 * 60 * 1000 },
                { path: '/api/auth/login', limit: 5, window: 15 * 60 * 1000 }
            ];
            
            for (const endpoint of endpoints) {
                // Make requests up to limit
                for (let i = 0; i < endpoint.limit; i++) {
                    await request(server)
                        .post(endpoint.path)
                        .send({});
                }
                
                // Next request should be rate limited
                const response = await request(server)
                    .post(endpoint.path)
                    .send({})
                    .expect(429);
                
                expect(response.body.error).toContain('Too many requests');
                expect(response.headers['x-ratelimit-limit']).toBeDefined();
                expect(response.headers['x-ratelimit-remaining']).toBe('0');
            }
        });
        
        test('should use different limits for different endpoints', async () => {
            // Stats endpoint has higher limit
            for (let i = 0; i < 100; i++) {
                const response = await request(server)
                    .get('/api/rgb/stats');
                
                expect(response.status).not.toBe(429);
            }
        });
    });
    
    describe('Cryptographic Security', () => {
        test('should not use Math.random() for security-critical operations', async () => {
            // This test would check the codebase, but we'll simulate
            // by checking API responses for proper randomness
            
            const invoices = [];
            for (let i = 0; i < 10; i++) {
                const response = await request(server)
                    .post('/api/rgb/invoice')
                    .send({
                        rgbInvoice: TestUtils.generateRGBInvoice(),
                        batchCount: 1,
                        walletAddress: TestUtils.generateBitcoinAddress()
                    });
                
                if (response.status === 200) {
                    invoices.push(response.body.invoiceId);
                }
            }
            
            // Check that invoice IDs are unique and properly random
            const uniqueInvoices = new Set(invoices);
            expect(uniqueInvoices.size).toBe(invoices.length);
            
            // Check entropy (simple check)
            invoices.forEach(id => {
                expect(id.length).toBeGreaterThanOrEqual(16);
                expect(id).toMatch(/^[a-zA-Z0-9-_]+$/);
            });
        });
        
        test('should properly hash sensitive data', async () => {
            // Check that responses don't contain raw sensitive data
            const response = await request(server)
                .get('/api/rgb/stats');
            
            const responseText = JSON.stringify(response.body);
            
            // Should not contain sensitive patterns
            expect(responseText).not.toMatch(/password|secret|private/i);
            expect(responseText).not.toMatch(/[A-Za-z0-9]{64}/); // No raw keys
        });
    });
    
    describe('CORS & CSP Headers', () => {
        test('should have proper CORS configuration', async () => {
            const response = await request(server)
                .get('/api/rgb/stats')
                .set('Origin', 'https://evil.com');
            
            // Should not allow arbitrary origins
            const allowedOrigin = response.headers['access-control-allow-origin'];
            expect(allowedOrigin).not.toBe('https://evil.com');
            expect(allowedOrigin).not.toBe('*');
        });
        
        test('should have security headers', async () => {
            const response = await request(server)
                .get('/api/rgb/stats');
            
            // Check security headers
            expect(response.headers['x-content-type-options']).toBe('nosniff');
            expect(response.headers['x-frame-options']).toBe('DENY');
            expect(response.headers['x-xss-protection']).toBe('1; mode=block');
            expect(response.headers['strict-transport-security']).toBeDefined();
        });
    });
    
    describe('Path Traversal', () => {
        test('should prevent path traversal attacks', async () => {
            const maliciousPaths = [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\system32\\config\\sam',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
                '....//....//....//etc/passwd',
                '..;/..;/..;/etc/passwd'
            ];
            
            for (const path of maliciousPaths) {
                // Try in different parameters
                const responses = await Promise.all([
                    request(server).get(`/api/file/${path}`),
                    request(server).get(`/api/rgb/invoice/${path}/status`),
                    request(server).post('/api/upload').send({ filename: path })
                ]);
                
                responses.forEach(response => {
                    expect([400, 404]).toContain(response.status);
                    expect(response.text).not.toMatch(/root:|system32|passwd/i);
                });
            }
        });
    });
    
    describe('Session Security', () => {
        test('should use secure session configuration', async () => {
            const response = await request(server)
                .post('/api/auth/login')
                .send({
                    username: 'test',
                    password: 'test'
                });
            
            if (response.headers['set-cookie']) {
                const cookies = response.headers['set-cookie'];
                cookies.forEach(cookie => {
                    expect(cookie).toMatch(/HttpOnly/i);
                    expect(cookie).toMatch(/SameSite=/i);
                    if (process.env.NODE_ENV === 'production') {
                        expect(cookie).toMatch(/Secure/i);
                    }
                });
            }
        });
    });
    
    describe('Information Disclosure', () => {
        test('should not expose stack traces in production', async () => {
            // Force an error
            const response = await request(server)
                .post('/api/rgb/invoice')
                .send({
                    rgbInvoice: { toString: null }, // Will cause error
                    batchCount: 'invalid'
                });
            
            expect(response.status).toBe(400);
            expect(response.body.error).toBeDefined();
            
            // Should not expose technical details
            expect(response.body.error).not.toMatch(/at\s+\w+\s+\(/); // Stack trace
            expect(response.body.error).not.toMatch(/node_modules/);
            expect(response.body.error).not.toMatch(/\.js:\d+:\d+/);
        });
        
        test('should not expose server technology', async () => {
            const response = await request(server)
                .get('/api/rgb/stats');
            
            // Should not expose server details
            expect(response.headers['x-powered-by']).toBeUndefined();
            expect(response.headers['server']).not.toMatch(/Express|Node/i);
        });
    });
    
    describe('Resource Limits', () => {
        test('should limit request body size', async () => {
            const largePayload = {
                rgbInvoice: TestUtils.generateRGBInvoice(),
                batchCount: 1,
                walletAddress: TestUtils.generateBitcoinAddress(),
                extra: 'x'.repeat(10 * 1024 * 1024) // 10MB
            };
            
            const response = await request(server)
                .post('/api/rgb/invoice')
                .send(largePayload);
            
            expect([413, 400]).toContain(response.status);
        });
        
        test('should timeout long-running requests', async () => {
            // This would need a special endpoint that delays
            // For now, we'll just verify timeout handling exists
            const startTime = Date.now();
            
            const response = await request(server)
                .get('/api/rgb/stats')
                .timeout(5000); // 5 second timeout
            
            const duration = Date.now() - startTime;
            expect(duration).toBeLessThan(6000);
        });
    });
});